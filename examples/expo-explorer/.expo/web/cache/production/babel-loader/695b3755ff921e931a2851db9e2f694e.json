{"ast":null,"code":"import _slicedToArray from\"@babel/runtime/helpers/slicedToArray\";import{useCallback,useRef,useState}from\"react\";export function useControlledState(value,defaultValue,onChange){var _useState=useState(value||defaultValue),_useState2=_slicedToArray(_useState,2),stateValue=_useState2[0],setStateValue=_useState2[1];var ref=useRef(value!==undefined);var wasControlled=ref.current;var isControlled=value!==undefined;var stateRef=useRef(stateValue);if(wasControlled!==isControlled){console.warn(\"WARN: A component changed from \"+(wasControlled?'controlled':'uncontrolled')+\" to \"+(isControlled?'controlled':'uncontrolled')+\".\");}ref.current=isControlled;var setValue=useCallback(function(value){for(var _len=arguments.length,args=new Array(_len>1?_len-1:0),_key=1;_key<_len;_key++){args[_key-1]=arguments[_key];}var onChangeCaller=function onChangeCaller(value){if(onChange){if(!Object.is(stateRef.current,value)){for(var _len2=arguments.length,onChangeArgs=new Array(_len2>1?_len2-1:0),_key2=1;_key2<_len2;_key2++){onChangeArgs[_key2-1]=arguments[_key2];}onChange.apply(void 0,[value].concat(onChangeArgs));}}if(!isControlled){stateRef.current=value;}};if(typeof value==='function'){var updateFunction=function updateFunction(oldValue){for(var _len3=arguments.length,functionArgs=new Array(_len3>1?_len3-1:0),_key3=1;_key3<_len3;_key3++){functionArgs[_key3-1]=arguments[_key3];}var interceptedValue=value.apply(void 0,[isControlled?stateRef.current:oldValue].concat(functionArgs));onChangeCaller.apply(void 0,[interceptedValue].concat(args));if(!isControlled){return interceptedValue;}return oldValue;};setStateValue(updateFunction);}else{if(!isControlled){setStateValue(value);}onChangeCaller.apply(void 0,[value].concat(args));}},[isControlled,onChange]);if(isControlled){stateRef.current=value;}else{value=stateValue;}return[value,setValue];}export function clamp(value,min,max){if(min===void 0){min=-Infinity;}if(max===void 0){max=Infinity;}var newValue=Math.min(Math.max(value,min),max);return newValue;}export function snapValueToStep(value,min,max,step){var remainder=(value-(isNaN(min)?0:min))%step;var snappedValue=Math.abs(remainder)*2>=step?value+Math.sign(remainder)*(step-Math.abs(remainder)):value-remainder;if(!isNaN(min)){if(snappedValue<min){snappedValue=min;}else if(!isNaN(max)&&snappedValue>max){snappedValue=min+Math.floor((max-min)/step)*step;}}else if(!isNaN(max)&&snappedValue>max){snappedValue=Math.floor(max/step)*step;}var string=step.toString();var index=string.indexOf('.');var precision=index>=0?string.length-index:0;if(precision>0){var pow=Math.pow(10,precision);snappedValue=Math.round(snappedValue*pow)/pow;}return snappedValue;}","map":{"version":3,"sources":["packages/@react-stately/utils/src/useControlledState.ts","packages/@react-stately/utils/src/number.ts"],"names":["useState","value","ref","useRef","wasControlled","isControlled","stateRef","console","setValue","useCallback","args","onChangeCaller","onChangeArgs","Object","onChange","updateFunction","functionArgs","interceptedValue","setStateValue","min","Infinity","max","newValue","Math","remainder","isNaN","snappedValue","step","string","index","precision","pow"],"mappings":"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","sourcesContent":["/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {useCallback, useRef, useState} from 'react';\n\nexport function useControlledState<T>(\n  value: T,\n  defaultValue: T,\n  onChange: (value: T, ...args: any[]) => void\n): [T, (value: T | ((prevState: T) => T), ...args: any[]) => void]  {\n  let [stateValue, setStateValue] = useState(value || defaultValue);\n  let ref = useRef(value !== undefined);\n  let wasControlled = ref.current;\n  let isControlled = value !== undefined;\n  // Internal state reference for useCallback\n  let stateRef = useRef(stateValue);\n  if (wasControlled !== isControlled) {\n    console.warn(`WARN: A component changed from ${wasControlled ? 'controlled' : 'uncontrolled'} to ${isControlled ? 'controlled' : 'uncontrolled'}.`);\n  }\n\n  ref.current = isControlled;\n\n  let setValue = useCallback((value, ...args) => {\n    let onChangeCaller = (value, ...onChangeArgs) => {\n      if (onChange) {\n        if (!Object.is(stateRef.current, value)) {\n          onChange(value, ...onChangeArgs);\n        }\n      }\n      if (!isControlled) {\n        stateRef.current = value;\n      }\n    };\n\n    if (typeof value === 'function') {\n      // this supports functional updates https://reactjs.org/docs/hooks-reference.html#functional-updates\n      // when someone using useControlledState calls setControlledState(myFunc)\n      // this will call our useState setState with a function as well which invokes myFunc and calls onChange with the value from myFunc\n      // if we're in an uncontrolled state, then we also return the value of myFunc which to setState looks as though it was just called with myFunc from the beginning\n      // otherwise we just return the controlled value, which won't cause a rerender because React knows to bail out when the value is the same\n      let updateFunction = (oldValue, ...functionArgs) => {\n        let interceptedValue = value(isControlled ? stateRef.current : oldValue, ...functionArgs);\n        onChangeCaller(interceptedValue, ...args);\n        if (!isControlled) {\n          return interceptedValue;\n        }\n        return oldValue;\n      };\n      setStateValue(updateFunction);\n    } else {\n      if (!isControlled) {\n        setStateValue(value);\n      }\n      onChangeCaller(value, ...args);\n    }\n  }, [isControlled, onChange]);\n\n  // If a controlled component's value prop changes, we need to update stateRef\n  if (isControlled) {\n    stateRef.current = value;\n  } else {\n    value = stateValue;\n  }\n\n  return [value, setValue];\n}\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\n/**\n * Takes a value and forces it to the closest min/max if it's outside. Also forces it to the closest valid step.\n */\nexport function clamp(value: number, min: number = -Infinity, max: number = Infinity): number {\n  let newValue = Math.min(Math.max(value, min), max);\n  return newValue;\n}\n\nexport function snapValueToStep(value: number, min: number, max: number, step: number): number {\n  let remainder = ((value - (isNaN(min) ? 0 : min)) % step);\n  let snappedValue = Math.abs(remainder) * 2 >= step\n    ? value + Math.sign(remainder) * (step - Math.abs(remainder))\n    : value - remainder;\n\n  if (!isNaN(min)) {\n    if (snappedValue < min) {\n      snappedValue = min;\n    } else if (!isNaN(max) && snappedValue > max) {\n      snappedValue = min + Math.floor((max - min) / step) * step;\n    }\n  } else if (!isNaN(max) && snappedValue > max) {\n    snappedValue = Math.floor(max / step) * step;\n  }\n\n  // correct floating point behavior by rounding to step precision\n  let string = step.toString();\n  let index = string.indexOf('.');\n  let precision = index >= 0 ? string.length - index : 0;\n\n  if (precision > 0) {\n    let pow = Math.pow(10, precision);\n    snappedValue = Math.round(snappedValue * pow) / pow;\n  }\n\n  return snappedValue;\n}\n"]},"metadata":{},"sourceType":"module"}