{"ast":null,"code":"import _defineProperty from\"@babel/runtime/helpers/defineProperty\";import _slicedToArray from\"@babel/runtime/helpers/slicedToArray\";function ownKeys(object,enumerableOnly){var keys=Object.keys(object);if(Object.getOwnPropertySymbols){var symbols=Object.getOwnPropertySymbols(object);if(enumerableOnly)symbols=symbols.filter(function(sym){return Object.getOwnPropertyDescriptor(object,sym).enumerable;});keys.push.apply(keys,symbols);}return keys;}function _objectSpread(target){for(var i=1;i<arguments.length;i++){var source=arguments[i]!=null?arguments[i]:{};if(i%2){ownKeys(Object(source),true).forEach(function(key){_defineProperty(target,key,source[key]);});}else if(Object.getOwnPropertyDescriptors){Object.defineProperties(target,Object.getOwnPropertyDescriptors(source));}else{ownKeys(Object(source)).forEach(function(key){Object.defineProperty(target,key,Object.getOwnPropertyDescriptor(source,key));});}}return target;}import{calculatePosition}from\"./calculatePosition\";import{useCallback,useRef,useState}from'react';import{useCloseOnScroll}from\"./useCloseOnScroll\";import{isRTL,useLayoutEffect}from'@react-native-aria/utils';var visualViewport=typeof window!=='undefined'&&window.visualViewport;export function useOverlayPosition(props){var direction=isRTL()?'rtl':undefined;var targetRef=props.targetRef,overlayRef=props.overlayRef,_props$scrollRef=props.scrollRef,scrollRef=_props$scrollRef===void 0?overlayRef:_props$scrollRef,_props$placement=props.placement,placement=_props$placement===void 0?'bottom':_props$placement,_props$containerPaddi=props.containerPadding,containerPadding=_props$containerPaddi===void 0?12:_props$containerPaddi,_props$shouldFlip=props.shouldFlip,shouldFlip=_props$shouldFlip===void 0?true:_props$shouldFlip,_props$boundaryElemen=props.boundaryElement,boundaryElement=_props$boundaryElemen===void 0?typeof document!=='undefined'?document.body:null:_props$boundaryElemen,_props$offset=props.offset,offset=_props$offset===void 0?0:_props$offset,_props$crossOffset=props.crossOffset,crossOffset=_props$crossOffset===void 0?0:_props$crossOffset,_props$shouldUpdatePo=props.shouldUpdatePosition,shouldUpdatePosition=_props$shouldUpdatePo===void 0?true:_props$shouldUpdatePo,_props$isOpen=props.isOpen,isOpen=_props$isOpen===void 0?true:_props$isOpen,_props$shouldOverlapW=props.shouldOverlapWithTrigger,shouldOverlapWithTrigger=_props$shouldOverlapW===void 0?false:_props$shouldOverlapW,onClose=props.onClose;var _useState=useState({position:{},arrowOffsetLeft:undefined,arrowOffsetTop:undefined,maxHeight:undefined,placement:undefined}),_useState2=_slicedToArray(_useState,2),position=_useState2[0],setPosition=_useState2[1];var deps=[shouldUpdatePosition,placement,overlayRef.current,targetRef.current,scrollRef.current,containerPadding,shouldFlip,boundaryElement,offset,crossOffset,isOpen,direction,shouldOverlapWithTrigger];var updatePosition=useCallback(function(){if(shouldUpdatePosition===false||!isOpen||!overlayRef.current||!targetRef.current||!scrollRef.current||!boundaryElement){return;}setPosition(calculatePosition({placement:translateRTL(placement,direction),overlayNode:overlayRef.current,targetNode:targetRef.current,scrollNode:scrollRef.current,padding:containerPadding,shouldFlip:shouldFlip,boundaryElement:boundaryElement,offset:offset,crossOffset:crossOffset,shouldOverlapWithTrigger:shouldOverlapWithTrigger}));},deps);useLayoutEffect(updatePosition,deps);useResize(updatePosition);var isResizing=useRef(false);useLayoutEffect(function(){var timeout;var onResize=function onResize(){isResizing.current=true;clearTimeout(timeout);timeout=setTimeout(function(){isResizing.current=false;},500);updatePosition();};visualViewport===null||visualViewport===void 0?void 0:visualViewport.addEventListener('resize',onResize);return function(){visualViewport===null||visualViewport===void 0?void 0:visualViewport.removeEventListener('resize',onResize);};},[updatePosition]);var close=useCallback(function(){if(!isResizing.current){onClose();}},[onClose,isResizing]);useCloseOnScroll({triggerRef:targetRef,isOpen:isOpen,onClose:onClose?close:undefined});return{rendered:true,overlayProps:{style:_objectSpread(_objectSpread({position:'absolute',zIndex:100000},position.position),{},{maxHeight:position.maxHeight})},placement:position.placement,arrowProps:{style:{left:position.arrowOffsetLeft,top:position.arrowOffsetTop}},updatePosition:updatePosition};}function useResize(onResize){useLayoutEffect(function(){window.addEventListener('resize',onResize,false);return function(){window.removeEventListener('resize',onResize,false);};},[onResize]);}function translateRTL(position,direction){if(direction==='rtl'){return position.replace('start','right').replace('end','left');}return position.replace('start','left').replace('end','right');}","map":{"version":3,"sources":["useOverlayPosition.ts"],"names":["visualViewport","window","direction","isRTL","scrollRef","placement","containerPadding","shouldFlip","boundaryElement","document","offset","crossOffset","shouldUpdatePosition","isOpen","shouldOverlapWithTrigger","onClose","useState","position","arrowOffsetLeft","arrowOffsetTop","maxHeight","undefined","deps","overlayRef","targetRef","updatePosition","useCallback","setPosition","calculatePosition","translateRTL","overlayNode","targetNode","scrollNode","padding","useLayoutEffect","useResize","isResizing","useRef","onResize","clearTimeout","timeout","setTimeout","close","useCloseOnScroll","triggerRef","rendered","overlayProps","style","zIndex","arrowProps","left","top"],"mappings":"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","sourcesContent":["//@ts-nocheck\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport { calculatePosition, PositionResult } from './calculatePosition';\nimport {\n  HTMLAttributes,\n  RefObject,\n  useCallback,\n  useRef,\n  useState,\n} from 'react';\nimport { Placement, PlacementAxis, PositionProps } from '@react-types/overlays';\nimport { useCloseOnScroll } from './useCloseOnScroll';\nimport { isRTL, useLayoutEffect } from '@react-native-aria/utils';\n\ninterface AriaPositionProps extends PositionProps {\n  /**\n   * Element that that serves as the positioning boundary.\n   * @default document.body\n   */\n  boundaryElement?: HTMLElement;\n  /**\n   * The ref for the element which the overlay positions itself with respect to.\n   */\n  targetRef: RefObject<HTMLElement>;\n  /**\n   * The ref for the overlay element.\n   */\n  overlayRef: RefObject<HTMLElement>;\n  /**\n   * A ref for the scrollable region within the overlay.\n   * @default overlayRef\n   */\n  scrollRef?: RefObject<HTMLElement>;\n  /**\n   * Whether the overlay should update its position automatically.\n   * @default true\n   */\n  shouldUpdatePosition?: boolean;\n  /** Handler that is called when the overlay should close. */\n  onClose?: () => void;\n  /** Determines whether the overlay should overlap with the trigger */\n  shouldOverlapWithTrigger?: boolean;\n}\n\ninterface PositionAria {\n  /** Props for the overlay container element. */\n  overlayProps: HTMLAttributes<Element>;\n  /** Props for the overlay tip arrow if any. */\n  arrowProps: HTMLAttributes<Element>;\n  /** Placement of the overlay with respect to the overlay trigger. */\n  placement: PlacementAxis;\n  /** Updates the position of the overlay. */\n  updatePosition(): void;\n}\n\n// @ts-ignore\nlet visualViewport = typeof window !== 'undefined' && window.visualViewport;\n\n/**\n * Handles positioning overlays like popovers and menus relative to a trigger\n * element, and updating the position when the window resizes.\n */\nexport function useOverlayPosition(props: AriaPositionProps): PositionAria {\n  const direction = isRTL() ? 'rtl' : undefined;\n  let {\n    targetRef,\n    overlayRef,\n    scrollRef = overlayRef,\n    placement = 'bottom' as Placement,\n    containerPadding = 12,\n    shouldFlip = true,\n    boundaryElement = typeof document !== 'undefined' ? document.body : null,\n    offset = 0,\n    crossOffset = 0,\n    shouldUpdatePosition = true,\n    isOpen = true,\n    shouldOverlapWithTrigger = false,\n    onClose,\n  } = props;\n  let [position, setPosition] = useState<PositionResult>({\n    position: {},\n    arrowOffsetLeft: undefined,\n    arrowOffsetTop: undefined,\n    maxHeight: undefined,\n    placement: undefined,\n  });\n\n  let deps = [\n    shouldUpdatePosition,\n    placement,\n    overlayRef.current,\n    targetRef.current,\n    scrollRef.current,\n    containerPadding,\n    shouldFlip,\n    boundaryElement,\n    offset,\n    crossOffset,\n    isOpen,\n    direction,\n    shouldOverlapWithTrigger\n  ];\n\n  let updatePosition = useCallback(() => {\n    if (\n      shouldUpdatePosition === false ||\n      !isOpen ||\n      !overlayRef.current ||\n      !targetRef.current ||\n      !scrollRef.current ||\n      !boundaryElement\n    ) {\n      return;\n    }\n\n    setPosition(\n      calculatePosition({\n        placement: translateRTL(placement, direction),\n        overlayNode: overlayRef.current,\n        targetNode: targetRef.current,\n        scrollNode: scrollRef.current,\n        padding: containerPadding,\n        shouldFlip,\n        boundaryElement,\n        offset,\n        crossOffset,\n        shouldOverlapWithTrigger,\n      })\n    );\n  }, deps);\n\n  // Update position when anything changes\n  useLayoutEffect(updatePosition, deps);\n\n  // Update position on window resize\n  useResize(updatePosition);\n\n  // Reposition the overlay and do not close on scroll while the visual viewport is resizing.\n  // This will ensure that overlays adjust their positioning when the iOS virtual keyboard appears.\n  let isResizing = useRef(false);\n  useLayoutEffect(() => {\n    let timeout: NodeJS.Timeout;\n    let onResize = () => {\n      isResizing.current = true;\n      clearTimeout(timeout);\n\n      timeout = setTimeout(() => {\n        isResizing.current = false;\n      }, 500);\n\n      updatePosition();\n    };\n\n    visualViewport?.addEventListener('resize', onResize);\n\n    return () => {\n      visualViewport?.removeEventListener('resize', onResize);\n    };\n  }, [updatePosition]);\n\n  let close = useCallback(() => {\n    if (!isResizing.current) {\n      onClose();\n    }\n  }, [onClose, isResizing]);\n\n  // When scrolling a parent scrollable region of the trigger (other than the body),\n  // we hide the popover. Otherwise, its position would be incorrect.\n  useCloseOnScroll({\n    triggerRef: targetRef,\n    isOpen,\n    onClose: onClose ? close : undefined,\n  });\n\n  return {\n    rendered: true,\n    overlayProps: {\n      style: {\n        position: 'absolute',\n        zIndex: 100000, // should match the z-index in ModalTrigger\n        ...position.position,\n        maxHeight: position.maxHeight,\n      },\n    },\n    placement: position.placement,\n    arrowProps: {\n      style: {\n        left: position.arrowOffsetLeft,\n        top: position.arrowOffsetTop,\n      },\n    },\n    updatePosition,\n  };\n}\n\nfunction useResize(onResize) {\n  useLayoutEffect(() => {\n    window.addEventListener('resize', onResize, false);\n    return () => {\n      window.removeEventListener('resize', onResize, false);\n    };\n  }, [onResize]);\n}\n\nfunction translateRTL(position, direction) {\n  if (direction === 'rtl') {\n    return position.replace('start', 'right').replace('end', 'left');\n  }\n  return position.replace('start', 'left').replace('end', 'right');\n}\n"]},"metadata":{},"sourceType":"module"}