{"ast":null,"code":"var _interopRequireWildcard=require(\"@babel/runtime/helpers/interopRequireWildcard\");var _interopRequireDefault=require(\"@babel/runtime/helpers/interopRequireDefault\");Object.defineProperty(exports,\"__esModule\",{value:true});exports.useColorModeValue=useColorModeValue;exports.useModeManager=useModeManager;exports.useAccessibleColors=useAccessibleColors;exports.useColorMode=void 0;var _regenerator=_interopRequireDefault(require(\"@babel/runtime/regenerator\"));var _slicedToArray2=_interopRequireDefault(require(\"@babel/runtime/helpers/slicedToArray\"));var _react=_interopRequireWildcard(require(\"react\"));var _Context=require(\"./../hybrid-overlay/Context\");var useColorMode=function useColorMode(){var _React$useContext=_react.default.useContext(_Context.HybridContext),colorModeContext=_React$useContext.colorMode;if(colorModeContext===undefined){throw new Error('useColorMode must be used within a NativeBaseProvider');}return colorModeContext;};exports.useColorMode=useColorMode;function useColorModeValue(light,dark){var _useColorMode=useColorMode(),colorMode=_useColorMode.colorMode;return colorMode==='dark'?dark:light;}function useModeManager(initialColorMode,colorModeManager){var _useState=(0,_react.useState)(initialColorMode),_useState2=(0,_slicedToArray2.default)(_useState,2),colorMode=_useState2[0],setRawMode=_useState2[1];function setColorMode(val){return _regenerator.default.async(function setColorMode$(_context){while(1){switch(_context.prev=_context.next){case 0:if(!colorModeManager){_context.next=3;break;}_context.next=3;return _regenerator.default.awrap(colorModeManager.set(val));case 3:setRawMode(val);case 4:case\"end\":return _context.stop();}}},null,null,null,Promise);}(0,_react.useEffect)(function(){if(colorModeManager){(function getMode(){var value;return _regenerator.default.async(function getMode$(_context2){while(1){switch(_context2.prev=_context2.next){case 0:_context2.next=2;return _regenerator.default.awrap(colorModeManager.get(initialColorMode));case 2:value=_context2.sent;if(value&&value!==colorMode){setRawMode(value);}case 4:case\"end\":return _context2.stop();}}},null,null,null,Promise);})();}},[colorMode,initialColorMode,colorModeManager]);return{colorMode:colorMode,setColorMode:setColorMode};}function useAccessibleColors(){var _React$useContext2=_react.default.useContext(_Context.HybridContext),colorModeContext=_React$useContext2.colorMode;var toggleAccessibleColors=function toggleAccessibleColors(){return colorModeContext.setAccessibleColors(!colorModeContext.accessibleColors);};return[colorModeContext.accessibleColors,colorModeContext.setAccessibleColors,toggleAccessibleColors];}","map":{"version":3,"sources":["hooks.tsx"],"names":["useColorMode","colorModeContext","React","HybridContext","colorMode","setRawMode","colorModeManager","value","setColorMode","toggleAccessibleColors"],"mappings":"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","sourcesContent":["import React, { useState, useEffect } from 'react';\nimport type {\n  ColorMode,\n  StorageManager,\n  IColorModeContextProps,\n} from './types';\nimport { HybridContext } from './../hybrid-overlay/Context';\nimport type { IHybridContextProps } from './../hybrid-overlay/types';\n\nexport const useColorMode = (): IColorModeContextProps => {\n  const {\n    colorMode: colorModeContext,\n  }: {\n    colorMode: IColorModeContextProps;\n  } = React.useContext<IHybridContextProps>(HybridContext);\n  if (colorModeContext === undefined) {\n    throw new Error('useColorMode must be used within a NativeBaseProvider');\n  }\n  return colorModeContext;\n};\n\nexport function useColorModeValue(light: any, dark: any) {\n  const { colorMode } = useColorMode();\n  return colorMode === 'dark' ? dark : light;\n}\n\nexport function useModeManager(\n  initialColorMode: ColorMode,\n  colorModeManager?: StorageManager\n) {\n  const [colorMode, setRawMode] = useState<ColorMode>(initialColorMode);\n  async function setColorMode(val: ColorMode) {\n    if (colorModeManager) {\n      await colorModeManager.set(val);\n    }\n    setRawMode(val);\n  }\n  // For initial setting initial color mode from storage\n  useEffect(() => {\n    if (colorModeManager) {\n      (async function getMode() {\n        let value = await colorModeManager.get(initialColorMode);\n        if (value && value !== colorMode) {\n          setRawMode(value);\n        }\n      })();\n    }\n  }, [colorMode, initialColorMode, colorModeManager]);\n\n  return { colorMode, setColorMode };\n}\n\nexport function useAccessibleColors(): [\n  boolean,\n  (val: boolean) => void,\n  () => void\n] {\n  const {\n    colorMode: colorModeContext,\n  }: {\n    colorMode: IColorModeContextProps;\n  } = React.useContext<IHybridContextProps>(HybridContext);\n  const toggleAccessibleColors = () =>\n    colorModeContext.setAccessibleColors(!colorModeContext.accessibleColors);\n  return [\n    colorModeContext.accessibleColors,\n    colorModeContext.setAccessibleColors,\n    toggleAccessibleColors,\n  ];\n}\n"]},"metadata":{},"sourceType":"script"}